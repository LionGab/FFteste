/**
 * üß† FULL FORCE ACADEMIA - MEMORY CORE MANAGEMENT SYSTEM üíæ
 * Sistema Inteligente de Gest√£o de Contexto e Mem√≥ria
 *
 * @description Gerenciamento avan√ßado de contexto e mem√≥ria para o bot
 * @features Token management, Context preservation, Memory optimization
 * @version 1.0.0
 */

class MemoryCoreManager {
  constructor() {
    this.tokenThreshold = 55000;
    this.currentTokenUsage = 0;
    this.memoryCore = this.initializeMemoryCore();
    this.contextCache = new Map();
    this.sessionData = new Map();
    this.compressionHistory = [];
  }

  /**
   * üíæ INICIALIZA√á√ÉO DO MEMORY CORE
   */
  initializeMemoryCore() {
    return {
      projectIdentity: {
        name: "Academia Full Force - Assistente Virtual WhatsApp",
        purpose: "Bot energ√©tico para agendamentos e atendimento de academia",
        personality: "Motivador, direto, energ√©tico (üî•üí™‚ö°)",
        coreStack: "Node.js + WhatsApp-Web.js + Google APIs",
        lastUpdated: new Date().toISOString()
      },

      architecture: {
        structure: "Modular: /handlers, /services, /utils, /config",
        mainFiles: {
          entry: "src/index.js",
          messageHandler: "src/handlers/message-handler.js",
          calendar: "src/services/google-calendar.js",
          sheets: "src/services/google-sheets.js",
          personality: "config/agent-personality.js",
          memoryCore: "config/memory-core-manager.js"
        },
        patterns: "Separation of concerns, Service-oriented, Event-driven"
      },

      coreFeatures: [
        "Reconhecimento de inten√ß√µes via regex",
        "Agendamento Google Calendar integrado",
        "Persist√™ncia em Google Sheets",
        "Sistema anti-spam (5s delay)",
        "Hor√°rios de funcionamento autom√°ticos",
        "Personalidade energ√©tica configurable",
        "Memory Core Management System",
        "Token usage optimization"
      ],

      technicalDebt: [
        "Sem testes automatizados",
        "Logging b√°sico (console.log)",
        "Valida√ß√£o de entrada limitada",
        "Cache inexistente para APIs",
        "Rate limiting ausente",
        "Monitoramento b√°sico"
      ],

      productionEnhancements: {
        phase1_foundation: [
          "Testing Framework (Jest + Supertest)",
          "Structured Logging (Winston)",
          "Input Validation (Joi/Yup)",
          "Error Handling Enhancement"
        ],
        phase2_performance: [
          "Intelligent Cache System",
          "Rate Limiting Implementation",
          "API Optimization",
          "Memory Management"
        ],
        phase3_production: [
          "Monitoring & Metrics",
          "Security & Deploy",
          "Admin Dashboard",
          "Backup & Recovery"
        ]
      }
    };
  }

  /**
   * üìä TOKEN USAGE MONITORING
   */
  estimateTokenUsage(text) {
    // Estimativa aproximada: 1 token ‚âà 4 caracteres
    return Math.ceil(text.length / 4);
  }

  updateTokenUsage(additionalTokens) {
    this.currentTokenUsage += additionalTokens;

    return {
      current: this.currentTokenUsage,
      threshold: this.tokenThreshold,
      percentage: (this.currentTokenUsage / this.tokenThreshold) * 100,
      needsCompression: this.currentTokenUsage > (this.tokenThreshold * 0.8)
    };
  }

  /**
   * üîÑ CONTEXT COMPRESSION SYSTEM
   */
  compressContext(conversationHistory, preserveMemoryCore = true) {
    const compressionResult = {
      timestamp: new Date().toISOString(),
      originalTokens: this.currentTokenUsage,
      compressedTokens: 0,
      preservedMemory: null,
      summary: null
    };

    if (preserveMemoryCore) {
      compressionResult.preservedMemory = this.memoryCore;
    }

    // Extrair informa√ß√µes essenciais das √∫ltimas intera√ß√µes
    const recentChanges = this.extractRecentChanges(conversationHistory);
    const progressStatus = this.extractProgressStatus(conversationHistory);
    const pendingTasks = this.extractPendingTasks(conversationHistory);

    // Criar resumo contextual
    compressionResult.summary = this.createContextSummary(
      recentChanges,
      progressStatus,
      pendingTasks
    );

    // Estimar tokens do contexto comprimido
    compressionResult.compressedTokens = this.estimateTokenUsage(
      JSON.stringify(compressionResult)
    );

    // Salvar no hist√≥rico de compress√£o
    this.compressionHistory.push(compressionResult);

    // Reset do contador de tokens
    this.currentTokenUsage = compressionResult.compressedTokens;

    return compressionResult;
  }

  /**
   * üìù EXTRA√á√ÉO DE MUDAN√áAS RECENTES
   */
  extractRecentChanges(conversationHistory) {
    const changes = [];
    const recentMessages = conversationHistory.slice(-10); // √öltimas 10 mensagens

    for (const message of recentMessages) {
      if (message.type === 'file_modification') {
        changes.push(`Modificado: ${message.file}`);
      } else if (message.type === 'implementation') {
        changes.push(`Implementado: ${message.feature}`);
      } else if (message.type === 'configuration') {
        changes.push(`Configurado: ${message.setting}`);
      }
    }

    return changes.slice(-5); // √öltimas 5 mudan√ßas
  }

  /**
   * üìà EXTRA√á√ÉO DE STATUS DE PROGRESSO
   */
  extractProgressStatus(conversationHistory) {
    const status = {
      currentPhase: "FOUNDATION",
      completedTasks: [],
      inProgressTasks: [],
      nextPriority: null
    };

    // An√°lise das mensagens para determinar progresso
    const recentMessages = conversationHistory.slice(-20);

    for (const message of recentMessages) {
      if (message.content && message.content.includes('FASE')) {
        if (message.content.includes('FOUNDATION')) status.currentPhase = 'FOUNDATION';
        if (message.content.includes('PERFORMANCE')) status.currentPhase = 'PERFORMANCE';
        if (message.content.includes('PRODUCTION')) status.currentPhase = 'PRODUCTION';
      }

      if (message.content && message.content.includes('‚úÖ')) {
        const completedTask = this.extractTaskFromMessage(message.content);
        if (completedTask) status.completedTasks.push(completedTask);
      }

      if (message.content && message.content.includes('üîÑ')) {
        const inProgressTask = this.extractTaskFromMessage(message.content);
        if (inProgressTask) status.inProgressTasks.push(inProgressTask);
      }
    }

    return status;
  }

  /**
   * üìã EXTRA√á√ÉO DE TAREFAS PENDENTES
   */
  extractPendingTasks(conversationHistory) {
    const tasks = [];
    const recentMessages = conversationHistory.slice(-15);

    for (const message of recentMessages) {
      if (message.content && message.content.includes('TODO')) {
        const task = this.extractTaskFromMessage(message.content);
        if (task) tasks.push(task);
      }
    }

    return tasks.slice(-3); // √öltimas 3 tarefas
  }

  /**
   * üéØ EXTRA√á√ÉO DE TAREFA DE MENSAGEM
   */
  extractTaskFromMessage(content) {
    const taskPatterns = [
      /(?:TODO|TAREFA|IMPLEMENTAR|CRIAR):\s*(.+)/i,
      /(?:‚úÖ|üîÑ|‚ùå)\s*(.+)/i,
      /(?:Pr√≥ximo|Next):\s*(.+)/i
    ];

    for (const pattern of taskPatterns) {
      const match = content.match(pattern);
      if (match) return match[1].trim();
    }

    return null;
  }

  /**
   * üìÑ CRIA√á√ÉO DE RESUMO CONTEXTUAL
   */
  createContextSummary(recentChanges, progressStatus, pendingTasks) {
    return `
CONTEXT RESET - MEMORIA PRESERVADA
Projeto: Academia Full Force Bot
Progresso: ${recentChanges.join(', ') || 'Configura√ß√£o inicial'}
Fase Atual: ${progressStatus.currentPhase}
Tarefas Completas: ${progressStatus.completedTasks.length}
Em Progresso: ${progressStatus.inProgressTasks.join(', ') || 'Nenhuma'}
Pr√≥ximo: ${pendingTasks[0] || 'Continuar roadmap de produ√ß√£o'}
Padr√µes: Energ√©tico üî•üí™‚ö°, Modular, Production-ready
    `.trim();
  }

  /**
   * üíæ SESS√ÉO DE USU√ÅRIO MANAGEMENT
   */
  createUserSession(userId, initialContext = {}) {
    const session = {
      id: userId,
      startTime: new Date().toISOString(),
      context: {
        userName: initialContext.userName || null,
        preferences: initialContext.preferences || {},
        conversationHistory: [],
        lastActivity: new Date().toISOString()
      },
      metrics: {
        messageCount: 0,
        avgResponseTime: 0,
        totalTokensUsed: 0
      }
    };

    this.sessionData.set(userId, session);
    return session;
  }

  updateUserSession(userId, update) {
    const session = this.sessionData.get(userId);
    if (!session) return null;

    session.context = { ...session.context, ...update };
    session.context.lastActivity = new Date().toISOString();
    session.metrics.messageCount++;

    this.sessionData.set(userId, session);
    return session;
  }

  getUserSession(userId) {
    return this.sessionData.get(userId) || null;
  }

  /**
   * üóÑÔ∏è CONTEXT CACHE MANAGEMENT
   */
  cacheContext(key, data, ttl = 300000) { // 5 minutos default
    const cacheEntry = {
      data,
      timestamp: Date.now(),
      ttl,
      expires: Date.now() + ttl
    };

    this.contextCache.set(key, cacheEntry);
    return cacheEntry;
  }

  getCachedContext(key) {
    const entry = this.contextCache.get(key);

    if (!entry) return null;

    if (Date.now() > entry.expires) {
      this.contextCache.delete(key);
      return null;
    }

    return entry.data;
  }

  clearExpiredCache() {
    const now = Date.now();
    for (const [key, entry] of this.contextCache.entries()) {
      if (now > entry.expires) {
        this.contextCache.delete(key);
      }
    }
  }

  /**
   * üîç MEMORY ANALYTICS
   */
  getMemoryAnalytics() {
    return {
      currentTokenUsage: this.currentTokenUsage,
      tokenThreshold: this.tokenThreshold,
      utilizationPercentage: (this.currentTokenUsage / this.tokenThreshold) * 100,

      memoryCore: {
        size: this.estimateTokenUsage(JSON.stringify(this.memoryCore)),
        lastUpdated: this.memoryCore.projectIdentity.lastUpdated
      },

      cache: {
        entries: this.contextCache.size,
        totalSize: this.estimateTokenUsage(JSON.stringify([...this.contextCache.values()]))
      },

      sessions: {
        active: this.sessionData.size,
        totalMessages: Array.from(this.sessionData.values())
          .reduce((sum, session) => sum + session.metrics.messageCount, 0)
      },

      compressionHistory: {
        count: this.compressionHistory.length,
        lastCompression: this.compressionHistory[this.compressionHistory.length - 1]
      }
    };
  }

  /**
   * üõ†Ô∏è MEMORY OPTIMIZATION
   */
  optimizeMemory() {
    const optimizations = [];

    // Limpar cache expirado
    this.clearExpiredCache();
    optimizations.push("Cache expirado limpo");

    // Limpar sess√µes inativas (>1 hora)
    const oneHourAgo = Date.now() - (60 * 60 * 1000);
    for (const [userId, session] of this.sessionData.entries()) {
      if (new Date(session.context.lastActivity).getTime() < oneHourAgo) {
        this.sessionData.delete(userId);
        optimizations.push(`Sess√£o inativa removida: ${userId}`);
      }
    }

    // Manter apenas as √∫ltimas 5 compress√µes
    if (this.compressionHistory.length > 5) {
      this.compressionHistory = this.compressionHistory.slice(-5);
      optimizations.push("Hist√≥rico de compress√£o otimizado");
    }

    return {
      optimizations,
      newAnalytics: this.getMemoryAnalytics()
    };
  }

  /**
   * üíø BACKUP & RESTORE
   */
  createBackup() {
    return {
      timestamp: new Date().toISOString(),
      memoryCore: this.memoryCore,
      tokenUsage: this.currentTokenUsage,
      compressionHistory: this.compressionHistory,
      cacheEntries: this.contextCache.size,
      activeSessions: this.sessionData.size
    };
  }

  restoreFromBackup(backup) {
    if (backup.memoryCore) {
      this.memoryCore = backup.memoryCore;
    }
    if (backup.tokenUsage) {
      this.currentTokenUsage = backup.tokenUsage;
    }
    if (backup.compressionHistory) {
      this.compressionHistory = backup.compressionHistory;
    }

    return {
      status: "RESTORED",
      timestamp: backup.timestamp,
      restoredComponents: Object.keys(backup)
    };
  }

  /**
   * üöÄ INICIALIZADOR
   */
  initialize() {
    console.log(`
üß† MEMORY CORE MANAGEMENT SYSTEM INITIALIZED! üíæ

üìä Token Management: ‚úÖ Active (${this.tokenThreshold} limit)
üíæ Memory Core: ‚úÖ Loaded
üóÑÔ∏è Context Cache: ‚úÖ Ready
üë• Session Management: ‚úÖ Online
üîÑ Compression System: ‚úÖ Standby
üìà Analytics: ‚úÖ Tracking

MEMORY SYSTEM READY FOR PRODUCTION! üî•üí™‚ö°
    `);

    return {
      status: "MEMORY_CORE_ACTIVE",
      analytics: this.getMemoryAnalytics(),
      ready: true
    };
  }
}

module.exports = MemoryCoreManager;